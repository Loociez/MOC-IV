(() => {
  const CHAT_API = 'https://moc.marocodes.eu/api/messages';
  const API_TOKEN = 'f684f5c2474a579a37e6747e92e3b8a4';
  const INTERVAL = 2000; // milliseconds delay after each fetch

  const chatLog = document.getElementById('chatLog');
  let lastKey = null;
  let isFetching = false;

  const escapeHtml = v =>
    String(v ?? '').replace(/[&<>"']/g, m =>
      ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])
    );

  function flattenMessage(msg) {
    if (typeof msg === 'string') return msg;

    if (Array.isArray(msg)) {
      return msg.map(part => {
        if (typeof part === 'string') return part;
        if (typeof part?.text === 'string') return part.text;
        return '';
      }).join('');
    }

    if (typeof msg?.text === 'string') return msg.text;

    return '';
  }

  function parseLine(raw) {
    const line = flattenMessage(raw?.message).trim();
    if (!line) return null;

    const timeMatch = line.match(/^\((\d{2}:\d{2})\)\s*/);
    const time = timeMatch ? timeMatch[1] : '';
    const content = timeMatch ? line.slice(timeMatch[0].length) : line;

    let textLine = content;
    let isDiscord = false;
    if (textLine.startsWith('(Discord)')) {
      isDiscord = true;
      textLine = textLine.replace('(Discord)', '').trim();
    }

    const colonIndex = textLine.indexOf(':');
    if (colonIndex === -1) {
      return { time, user: '', text: textLine, tag: null, system: true };
    }

    return {
      time,
      user: textLine.slice(0, colonIndex).trim(),
      text: textLine.slice(colonIndex + 1).trim(),
      tag: isDiscord ? 'Discord' : null,
      system: false
    };
  }

  function keyOf(raw) {
    return flattenMessage(raw?.message);
  }

  async function fetchChat() {
    if (isFetching) return;  // Just in case, avoid overlapping fetches
    isFetching = true;

    try {
      const res = await fetch(CHAT_API, {
        headers: { Authorization: `Bearer ${API_TOKEN}` }
      });
      if (!res.ok) throw new Error('API error');

      const data = await res.json();
      if (Array.isArray(data)) {
        render(data.slice().reverse());
      }
    } catch (e) {
      console.error(e);
      chatLog.textContent = 'Error loading chat.';
    } finally {
      isFetching = false;
      // Wait INTERVAL milliseconds then fetch again
      setTimeout(fetchChat, INTERVAL);
    }
  }

  function render(lines) {
    const newestKey = keyOf(lines.at(-1));

    chatLog.innerHTML = lines.map(raw => {
      const parsed = parseLine(raw);
      if (!parsed) return '';

      // Determine if this line is the newest (only the last line)
      const isNew = lastKey && keyOf(raw) === newestKey && newestKey !== lastKey;

      if (parsed.system) {
        return `<div class="chat-line ${isNew ? 'new' : ''}">
          <span class="system">${escapeHtml(parsed.text)}</span>
        </div>`;
      }

      if (parsed.tag === 'Discord') {
        return `<div class="chat-line ${isNew ? 'new' : ''}">
          <span class="time">(${parsed.time})</span>
          <span class="discord">(Discord)</span>
          <span class="user">${escapeHtml(parsed.user)}:</span>
          <span class="text">${escapeHtml(parsed.text)}</span>
        </div>`;
      }

      return `<div class="chat-line ${isNew ? 'new' : ''}">
        <span class="time">(${parsed.time})</span>
        <span class="user">${escapeHtml(parsed.user)}:</span>
        <span class="text">${escapeHtml(parsed.text)}</span>
      </div>`;
    }).join('');

    lastKey = newestKey;
    chatLog.scrollTop = chatLog.scrollHeight;
  }

  // Start the first fetch
  fetchChat();
})();
