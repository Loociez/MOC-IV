<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Item Table View</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: purple;
      color: gold;
      margin: 0;
      padding: 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background-color: #4b0082;
      color: gold;
    }
    th,
    td {
      border: 1px solid gold;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #6a0dad;
    }
    tr:nth-child(even) {
      background-color: #5a0088;
    }
    .data {
      font-size: 0.9em;
      color: #eee;
      white-space: pre-line;
    }
    #searchBar {
      margin: 20px auto;
      display: block;
      width: 90%;
      padding: 10px;
      font-size: 1em;
      border: 1px solid gold;
      border-radius: 4px;
      background-color: #4b0082;
      color: gold;
    }
    #searchBar::placeholder {
      color: gold;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
      color: gold;
    }
    select {
      background-color: #4b0082;
      color: gold;
      border: 1px solid gold;
    }
  </style>
</head>
<body>
  <h1 id="itemListHeading">Last Known 07/04/25 - Item List</h1>
  <select id="languageSelector" onchange="changeLanguage(this.value)">
    <option value="en">English</option>
    <option value="es">Espa√±ol</option>
  </select>

  <input
    type="text"
    id="searchBar"
    placeholder="Search for an item..."
    oninput="filterTable()"
  />
  <label style="margin-left: 10px;" id="weaponFilterLabel"
    ><input type="checkbox" id="weaponFilter" onclick="filterTable()" />
    Weapons Only</label
  >
  <label style="margin-left: 10px;" id="petFilterLabel"
    ><input type="checkbox" id="petFilter" onclick="filterTable()" /> Pets
    Only</label
  >
  <label style="margin-left: 10px;" id="recipeFilterLabel"
    ><input type="checkbox" id="recipeFilter" onclick="filterTable()" /> Recipes
    Only</label
  >
  <label style="margin-left: 10px;" id="rareFilterLabel"
    ><input type="checkbox" id="rareFilter" onclick="filterTable()" /> Rare+</label
  >
  <label style="margin-left: 10px;" id="favoritesFilterLabel"
    ><input
      type="checkbox"
      id="favoritesFilter"
      onclick="filterTable()"
    /> Show Favorites Only</label
  >

  <label for="sortStat" style="margin-left: 10px;">Sort by:</label>
  <select id="sortStat" onchange="filterTable()">
    <option value="">-- None --</option>
    <option value="max_atk">Max Physical Attack</option>
    <option value="max_mat">Max Magical Attack</option>
    <option value="max_hp">Max HP</option>
    <option value="max_def">Max Defense</option>
    <option value="max_mdf">Max M. Defense</option>
    <option value="max_rat">Max Ranged Attack</option>
    <option value="max_rdf">Max Ranged Defense</option>
  </select>

  <button onclick="clearComparison()">Clear Comparison</button>
  <button onclick="clearFavorites()">Clear Favorites</button>
  <button onclick="generateShareLink()">Share Comparison</button>
  <button onclick="copyStats()">Copy Stats</button>
  <button onclick="copyDescription()">Copy Description</button>

  <table id="itemTable">
    <thead>
      <tr>
        <th>Select</th>
        <th>Name</th>
        <th>Description</th>
        <th>Stats</th>
        <th>Repair Cost</th>
        <th>Uses</th>
        <th>Sell Value</th>
        <th>Handedness</th>
        <th>Fav's</th>
      </tr>
    </thead>
    <tbody>
      <!-- Rows populated dynamically -->
    </tbody>
  </table>

 <script>
let selectedItems = [];

async function fetchWithTimeout(url, timeout = 5000) {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => reject(new Error('Request timed out')), timeout);
        fetch(url).then(response => {
            clearTimeout(timer);
            if (!response.ok) reject(new Error(`HTTP error! status: ${response.status}`));
            else resolve(response);
        }).catch(err => {
            clearTimeout(timer);
            reject(err);
        });
    });
}

async function fetchItemData() {
    try {
        const response = await fetch('last.json');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Failed to fetch item data:', error);
    }
}

function isFavorite(name) {
    const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
    return favorites.includes(name);
}

function toggleFavorite(item) {
    let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
    if (favorites.includes(item.name)) {
        favorites = favorites.filter(name => name !== item.name);
    } else {
        favorites.push(item.name);
    }
    localStorage.setItem('favorites', JSON.stringify(favorites));
    filterTable(); // Reapply filter after favorite toggle
}

async function fetchAndDisplayItems() {
    try {
        let items = await fetchItemData();

        const sortKey = document.getElementById("sortStat")?.value;
        if (sortKey && sortKey !== "none") {
            items.sort((a, b) => {
                const aValue = a.data?.[sortKey] ?? -Infinity;
                const bValue = b.data?.[sortKey] ?? -Infinity;
                return bValue - aValue;
            });
        }

        const tableBody = document.getElementById('itemTable').querySelector('tbody');
        tableBody.innerHTML = '';

       items.forEach(item => {
    const row = document.createElement('tr');

    const selectCell = document.createElement('td');
    const selectCheckbox = document.createElement('input');
    selectCheckbox.type = 'checkbox';
    selectCheckbox.value = item.name;
    selectCheckbox.onclick = () => handleItemSelection(item, selectCheckbox);
    selectCell.appendChild(selectCheckbox);
    row.appendChild(selectCell);

    const nameCell = document.createElement('td');
    nameCell.innerHTML = item.name;
    if (item.data?.level_req !== undefined) {
        nameCell.innerHTML += `<br><span style="font-size: 0.85em; color: #ccc;">Level: ${item.data.level_req}</span>`;
    }
    row.appendChild(nameCell);

    const descCell = document.createElement('td');
    descCell.textContent = item.desc || 'No description';
    row.appendChild(descCell);

    const dataCell = document.createElement('td');
    let stats = item.data ? Object.entries(item.data) : [];
    if (item.tile_range) stats.push(['tile range', item.tile_range]);

    const excludedKeys = ["hue", "move", "spin", "alpha", "scale", "sprite", "brightness", "saturation", "damage stat"];
    const groupedStats = {};
    stats.forEach(([key, value]) => {
        if (excludedKeys.includes(key.toLowerCase()) || key.startsWith('!')) return;
        const match = key.match(/^(min|max)_(.+)$/);
        if (match) {
            const [, bound, statName] = match;
            if (!groupedStats[statName]) groupedStats[statName] = {};
            groupedStats[statName][bound] = value;
        } else {
            groupedStats[key] = value;
        }
    });


            let formattedLines = Object.entries(groupedStats).map(([key, value]) => {
    if (typeof value === 'object') {
        const min = value.min;
        const max = value.max;
        if (min !== undefined && max !== undefined) return `${key}: ${min} - ${max}`;
        else if (min !== undefined) return `${key} (min): ${min}`;
        else if (max !== undefined) return `${key} (max): ${max}`;
        else return `${key}: ?`;
    }
    return `${key.replace(/_/g, ' ')}: ${value}`;
});

// ** Added level_req display here under stats as requested **
if (item.data?.level_req !== undefined) {
    formattedLines.push(`Level: ${item.data.level_req}`);
}

const spellAmpKeys = [
    "!bard_buff_uptime", "!jester_confuse_cost", "!bard_critical_chance", "!bard_dps", "!bard_fire_dot",
    "!bard_fire_dot_aoe", "!bard_ice_dot", "!bard_ice_dot_aoe", "!bard_pet_bonus", "!bard_summon_bonus",
    "!bard_warcry_bonus", "!bard_wind_dot", "!bard_wind_dot_aoe", "!bard_wind_resistance", "!bard_wind_spell_resistance",
    "!bard_wind_spell_damage", "!bard_wind_spell_healing", "!bard_wind_spell_range", "!bard_wind_spell_radius"
];

formattedLines = formattedLines.filter(line => !spellAmpKeys.some(key => line.toLowerCase().includes(key)));

dataCell.innerHTML = `<pre class="data">${formattedLines.join('\n')}</pre>`;
row.appendChild(dataCell);

    const repairCell = document.createElement('td');
    repairCell.textContent = item.repair?.cost || '-';
    row.appendChild(repairCell);

    const usesCell = document.createElement('td');
    usesCell.textContent = item.uses ?? '-';
    row.appendChild(usesCell);

    const sellCell = document.createElement('td');
    sellCell.textContent = item.sell_value ?? '-';
    row.appendChild(sellCell);

    const handedCell = document.createElement('td');
    handedCell.textContent = item.handed ?? '-';
    row.appendChild(handedCell);

    const favCell = document.createElement('td');
    const favCheckbox = document.createElement('input');
    favCheckbox.type = 'checkbox';
    favCheckbox.checked = isFavorite(item.name);
    favCheckbox.onclick = () => toggleFavorite(item);
    favCell.appendChild(favCheckbox);
    row.appendChild(favCell);

    tableBody.appendChild(row);
});

        filterTable();
    } catch (error) {
        console.error('Error loading items:', error);
    }
}

function handleItemSelection(item, checkbox) {
    if (checkbox.checked) {
        if (!selectedItems.find(i => i.name === item.name)) {
            selectedItems.push(item);
        }
    } else {
        selectedItems = selectedItems.filter(i => i.name !== item.name);
    }
}

function filterTable() {
    const searchTerm = document.getElementById('searchBar').value.toLowerCase();
    const weaponOnly = document.getElementById('weaponFilter').checked;
    const petsOnly = document.getElementById('petFilter').checked;
    const recipesOnly = document.getElementById('recipeFilter').checked;
    const rareOnly = document.getElementById('rareFilter').checked;
    const favOnly = document.getElementById('favoritesFilter').checked;
    const sortStat = document.getElementById('sortStat').value;

    const tableBody = document.getElementById('itemTable').querySelector('tbody');
    const rows = tableBody.querySelectorAll('tr');

    rows.forEach(row => {
        const cells = row.cells;
        const name = cells[1].textContent.toLowerCase();
        const desc = cells[2].textContent.toLowerCase();
        const stats = cells[3].textContent.toLowerCase();

        let show = true;

        if (searchTerm && !name.includes(searchTerm) && !desc.includes(searchTerm)) show = false;

        if (weaponOnly && !name.includes('sword') && !name.includes('axe') && !name.includes('dagger') && !name.includes('bow') && !name.includes('weapon')) show = false;
        if (petsOnly && !desc.includes('pet')) show = false;
        if (recipesOnly && !desc.includes('recipe')) show = false;
        if (rareOnly && !desc.includes('rare') && !desc.includes('legendary')) show = false;
        if (favOnly && !cells[8].querySelector('input').checked) show = false;

        row.style.display = show ? '' : 'none';
    });
}

function clearComparison() {
    selectedItems = [];
    const checkboxes = document.querySelectorAll('#itemTable tbody input[type="checkbox"]');
    checkboxes.forEach(cb => (cb.checked = false));
}

function clearFavorites() {
    localStorage.removeItem('favorites');
    filterTable();
}

function generateShareLink() {
    if (selectedItems.length === 0) {
        alert('No items selected to share!');
        return;
    }
    const baseUrl = window.location.href.split('?')[0];
    const itemNames = selectedItems.map(i => encodeURIComponent(i.name)).join(',');
    const shareUrl = `${baseUrl}?items=${itemNames}`;
    prompt('Share this URL:', shareUrl);
}

function copyStats() {
    if (selectedItems.length === 0) {
        alert('No items selected!');
        return;
    }
    let text = '';
    selectedItems.forEach(item => {
        text += `${item.name}\n`;
        if (item.data) {
            for (const [key, value] of Object.entries(item.data)) {
                text += `${key}: ${value}\n`;
            }
        }
        text += '\n';
    });
    navigator.clipboard.writeText(text);
    alert('Stats copied to clipboard.');
}

function copyDescription() {
    if (selectedItems.length === 0) {
        alert('No items selected!');
        return;
    }
    let text = '';
    selectedItems.forEach(item => {
        text += `${item.name}: ${item.desc}\n\n`;
    });
    navigator.clipboard.writeText(text);
    alert('Descriptions copied to clipboard.');
}

function changeLanguage(lang) {
    // Stub for language change
    alert(`Language change to ${lang} not implemented yet.`);
}

// Load items on page load
window.onload = fetchAndDisplayItems;
</script>
</body>
</html>
