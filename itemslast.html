<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Item Table View</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: purple;
      color: gold;
      margin: 0;
      padding: 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background-color: #4b0082;
      color: gold;
    }
    th,
    td {
      border: 1px solid gold;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #6a0dad;
    }
    tr:nth-child(even) {
      background-color: #5a0088;
    }
    .data {
      font-size: 0.9em;
      color: #eee;
      white-space: pre-line;
    }
    #searchBar {
      margin: 20px auto;
      display: block;
      width: 90%;
      padding: 10px;
      font-size: 1em;
      border: 1px solid gold;
      border-radius: 4px;
      background-color: #4b0082;
      color: gold;
    }
    #searchBar::placeholder {
      color: gold;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
      color: gold;
    }
    select {
      background-color: #4b0082;
      color: gold;
      border: 1px solid gold;
    }
  </style>
</head>
<body>
  <h1 id="itemListHeading">Last Known 07/04/25 - Item List</h1>
  <select id="languageSelector" onchange="changeLanguage(this.value)">
    <option value="en">English</option>
    <option value="es">Espa√±ol</option>
  </select>

  <input
    type="text"
    id="searchBar"
    placeholder="Search for an item..."
    oninput="filterTable()"
  />
  <label style="margin-left: 10px;" id="weaponFilterLabel"
    ><input type="checkbox" id="weaponFilter" onclick="filterTable()" />
    Weapons Only</label
  >
  <label style="margin-left: 10px;" id="petFilterLabel"
    ><input type="checkbox" id="petFilter" onclick="filterTable()" /> Pets
    Only</label
  >
  <label style="margin-left: 10px;" id="recipeFilterLabel"
    ><input type="checkbox" id="recipeFilter" onclick="filterTable()" /> Recipes
    Only</label
  >
  <label style="margin-left: 10px;" id="rareFilterLabel"
    ><input type="checkbox" id="rareFilter" onclick="filterTable()" /> Rare+</label
  >
  <label style="margin-left: 10px;" id="favoritesFilterLabel"
    ><input
      type="checkbox"
      id="favoritesFilter"
      onclick="filterTable()"
    /> Show Favorites Only</label
  >

  <label for="sortStat" style="margin-left: 10px;">Sort by:</label>
  <select id="sortStat" onchange="filterTable()">
    <option value="">-- None --</option>
    <option value="max_atk">Max Physical Attack</option>
    <option value="max_mat">Max Magical Attack</option>
    <option value="max_hp">Max HP</option>
    <option value="max_def">Max Defense</option>
    <option value="max_mdf">Max M. Defense</option>
    <option value="max_rat">Max Ranged Attack</option>
    <option value="max_rdf">Max Ranged Defense</option>
  </select>

  <button onclick="clearComparison()">Clear Comparison</button>
  <button onclick="clearFavorites()">Clear Favorites</button>
  <button onclick="generateShareLink()">Share Comparison</button>
  <button onclick="copyStats()">Copy Stats</button>
  <button onclick="copyDescription()">Copy Description</button>

  <table id="itemTable">
    <thead>
      <tr>
        <th>Select</th>
        <th>Name</th>
        <th>Description</th>
        <th>Stats</th>
        <th>Repair Cost</th>
        <th>Uses</th>
        <th>Sell Value</th>
        <th>Handedness</th>
        <th>Fav's</th>
      </tr>
    </thead>
    <tbody>
      <!-- Rows populated dynamically -->
    </tbody>
  </table>

<script>
let selectedItems = [];

async function fetchWithTimeout(url, timeout = 5000) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject(new Error('Request timed out')), timeout);
    fetch(url).then(response => {
      clearTimeout(timer);
      if (!response.ok) reject(new Error(`HTTP error! status: ${response.status}`));
      else resolve(response);
    }).catch(err => {
      clearTimeout(timer);
      reject(err);
    });
  });
}

async function fetchItemData() {
  try {
    const response = await fetch('last.json');
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch item data:', error);
  }
}

function isFavorite(name) {
  const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
  return favorites.includes(name);
}

function toggleFavorite(item) {
  let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
  if (favorites.includes(item.name)) {
    favorites = favorites.filter(name => name !== item.name);
  } else {
    favorites.push(item.name);
  }
  localStorage.setItem('favorites', JSON.stringify(favorites));
  filterTable();
}

async function fetchAndDisplayItems() {
  try {
    let items = await fetchItemData();

    const sortKey = document.getElementById("sortStat")?.value;
    if (sortKey && sortKey !== "none") {
      items.sort((a, b) => {
        const aValue = a.data?.[sortKey] ?? -Infinity;
        const bValue = b.data?.[sortKey] ?? -Infinity;
        return bValue - aValue;
      });
    }

    const tableBody = document.getElementById('itemTable').querySelector('tbody');
    tableBody.innerHTML = '';

    items.forEach(item => {
      const row = document.createElement('tr');

      const selectCell = document.createElement('td');
      const selectCheckbox = document.createElement('input');
      selectCheckbox.type = 'checkbox';
      selectCheckbox.value = item.name;
      selectCheckbox.onclick = () => handleItemSelection(item, selectCheckbox);
      selectCell.appendChild(selectCheckbox);
      row.appendChild(selectCell);

      const nameCell = document.createElement('td');
      const levelReq = item.data?.level_req;
      nameCell.innerHTML = item.name;
      if (levelReq !== undefined) {
        nameCell.innerHTML += `<br><span style="font-size: 0.85em; color: #ccc;">Level: ${levelReq}</span>`;
      }
      row.appendChild(nameCell);

      const descCell = document.createElement('td');
      descCell.textContent = item.desc || 'No description';
      row.appendChild(descCell);

      const dataCell = document.createElement('td');
      let stats = item.data ? Object.entries(item.data) : [];
      if (item.tile_range) stats.push(['tile range', item.tile_range]);

      const excludedKeys = ["hue", "move", "spin", "alpha", "scale", "sprite", "brightness", "saturation", "damage stat"];
      const groupedStats = {};
      stats.forEach(([key, value]) => {
        if (excludedKeys.includes(key.toLowerCase()) || key.startsWith('!')) return;
        const match = key.match(/^(min|max)_(.+)$/);
        if (match) {
          const [, bound, statName] = match;
          if (!groupedStats[statName]) groupedStats[statName] = {};
          groupedStats[statName][bound] = value;
        } else {
          groupedStats[key] = value;
        }
      });

      let formattedLines = Object.entries(groupedStats).map(([key, value]) => {
        if (typeof value === 'object') {
          const min = value.min;
          const max = value.max;
          if (min !== undefined && max !== undefined) return `${key}: ${min} - ${max}`;
          else if (min !== undefined) return `${key} (min): ${min}`;
          else if (max !== undefined) return `${key} (max): ${max}`;
          else return `${key}: ?`;
        }
        return `${key.replace(/_/g, ' ')}: ${value}`;
      });

      const spellAmpKeys = [
        "!bard_buff_uptime", "!jester_confuse_cost", "!cleric_petheal_amount",
        "!dragoon_npcaoe_damage", "!warlock_npcaoe_damage", "!cleric_playerheal_amount",
        "!dragoon_playeraoe_damage", "!warlock_playeraoe_damage", "!assassin_npcpoison_damage",
        "!necromancer_minion_damage", "!samurai_npcriposte_damage", "!barbarian_alldamage_amount",
        "!marksman_npcshotgun_damage", "!assassin_playerpoison_damage", "!samurai_playerriposte_damage",
        "!marksman_playershotgun_damage", "!vampire_npclifesteal_amount", "!vampire_playerlifesteal_amount"
      ];

      const spellAmpEntries = spellAmpKeys
        .filter(key => item.data?.[key] !== undefined)
        .map(key => `${key.replace(/_/g, ' ')}: ${item.data[key]}`);

      if (spellAmpEntries.length > 0) {
        formattedLines.push("");
        formattedLines.push("Spell Amp:");
        formattedLines.push(...spellAmpEntries);
      }

      const formattedData = formattedLines.join('\n');

      dataCell.textContent = formattedData.trim() || 'No stats';
      dataCell.classList.add('data');
      row.appendChild(dataCell);

      const repairCostCell = document.createElement('td');
      repairCostCell.textContent = item.repair_cost || 'No repair cost';
      row.appendChild(repairCostCell);

      const usesCell = document.createElement('td');
      usesCell.textContent = item.uses || 'No uses data';
      row.appendChild(usesCell);

      const sellValueCell = document.createElement('td');
      sellValueCell.textContent = item.recycle_value || 'No sell value';
      row.appendChild(sellValueCell);

      const handednessCell = document.createElement('td');
      const isTwoHanded = item.data && (item.data.two_handed === true || item.data.two_handed === 'true');
      handednessCell.textContent = isTwoHanded ? 'Two Handed' : 'One Handed';
      row.appendChild(handednessCell);

      const favoriteCell = document.createElement('td');
      const favoriteCheckbox = document.createElement('input');
      favoriteCheckbox.type = 'checkbox';
      favoriteCheckbox.checked = isFavorite(item.name);
      favoriteCheckbox.onclick = () => toggleFavorite(item);
      favoriteCell.appendChild(favoriteCheckbox);
      row.appendChild(favoriteCell);

      tableBody.appendChild(row);
    });

    filterTable();
  } catch (error) {
    console.error('Error fetching or displaying data:', error);
    alert(`Failed to load data: ${error.message}`);
  }
}
</script>
</body>
</html>
