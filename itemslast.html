<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Item Table View</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: purple;
      color: gold;
      margin: 0;
      padding: 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background-color: #4b0082;
      color: gold;
    }
    th,
    td {
      border: 1px solid gold;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #6a0dad;
    }
    tr:nth-child(even) {
      background-color: #5a0088;
    }
    .data {
      font-size: 0.9em;
      color: #eee;
      white-space: pre-line;
    }
    #searchBar {
      margin: 20px auto;
      display: block;
      width: 90%;
      padding: 10px;
      font-size: 1em;
      border: 1px solid gold;
      border-radius: 4px;
      background-color: #4b0082;
      color: gold;
    }
    #searchBar::placeholder {
      color: gold;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
      color: gold;
    }
    select {
      background-color: #4b0082;
      color: gold;
      border: 1px solid gold;
    }
  </style>
</head>
<body>
  <h1 id="itemListHeading">Last Known 07/04/25 - Item List</h1>
  <select id="languageSelector" onchange="changeLanguage(this.value)">
    <option value="en">English</option>
    <option value="es">Español</option>
  </select>

  <input
    type="text"
    id="searchBar"
    placeholder="Search for an item..."
    oninput="filterTable()"
  />
  <label style="margin-left: 10px;" id="weaponFilterLabel"
    ><input type="checkbox" id="weaponFilter" onclick="filterTable()" />
    Weapons Only</label
  >
  <label style="margin-left: 10px;" id="petFilterLabel"
    ><input type="checkbox" id="petFilter" onclick="filterTable()" /> Pets
    Only</label
  >
  <label style="margin-left: 10px;" id="recipeFilterLabel"
    ><input type="checkbox" id="recipeFilter" onclick="filterTable()" /> Recipes
    Only</label
  >
  <label style="margin-left: 10px;" id="rareFilterLabel"
    ><input type="checkbox" id="rareFilter" onclick="filterTable()" /> Rare+</label
  >
  <label style="margin-left: 10px;" id="favoritesFilterLabel"
    ><input
      type="checkbox"
      id="favoritesFilter"
      onclick="filterTable()"
    /> Show Favorites Only</label
  >

  <label for="sortStat" style="margin-left: 10px;">Sort by:</label>
  <select id="sortStat" onchange="filterTable()">
    <option value="">-- None --</option>
    <option value="max_atk">Max Physical Attack</option>
    <option value="max_mat">Max Magical Attack</option>
    <option value="max_hp">Max HP</option>
    <option value="max_def">Max Defense</option>
    <option value="max_mdf">Max M. Defense</option>
    <option value="max_rat">Max Ranged Attack</option>
    <option value="max_rdf">Max Ranged Defense</option>
  </select>

  <button onclick="clearComparison()">Clear Comparison</button>
  <button onclick="clearFavorites()">Clear Favorites</button>
  <button onclick="generateShareLink()">Share Comparison</button>
  <button onclick="copyStats()">Copy Stats</button>
  <button onclick="copyDescription()">Copy Description</button>

  <table id="itemTable">
    <thead>
      <tr>
        <th>Select</th>
        <th>Name</th>
        <th>Description</th>
        <th>Stats</th>
        <th>Repair Cost</th>
        <th>Uses</th>
        <th>Sell Value</th>
        <th>Handedness</th>
        <th>Fav's</th>
      </tr>
    </thead>
    <tbody>
      <!-- Rows populated dynamically -->
    </tbody>
  </table>

 <script>
let selectedItems = [];

async function fetchWithTimeout(url, timeout = 5000) {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => reject(new Error('Request timed out')), timeout);
        fetch(url).then(response => {
            clearTimeout(timer);
            if (!response.ok) reject(new Error(`HTTP error! status: ${response.status}`));
            else resolve(response);
        }).catch(err => {
            clearTimeout(timer);
            reject(err);
        });
    });
}

async function fetchItemData() {
    try {
        const response = await fetch('last.json');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Failed to fetch item data:', error);
    }
}

function isFavorite(name) {
    const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
    return favorites.includes(name);
}

function toggleFavorite(item) {
    let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
    if (favorites.includes(item.name)) {
        favorites = favorites.filter(name => name !== item.name);
    } else {
        favorites.push(item.name);
    }
    localStorage.setItem('favorites', JSON.stringify(favorites));
    filterTable(); // Reapply filter after favorite toggle
}

async function fetchAndDisplayItems() {
    try {
        let items = await fetchItemData();

        const sortKey = document.getElementById("sortStat")?.value;
        if (sortKey && sortKey !== "none") {
            items.sort((a, b) => {
                const aValue = a.data?.[sortKey] ?? -Infinity;
                const bValue = b.data?.[sortKey] ?? -Infinity;
                return bValue - aValue;
            });
        }

        const tableBody = document.getElementById('itemTable').querySelector('tbody');
        tableBody.innerHTML = '';

       items.forEach(item => {
    const row = document.createElement('tr');

    const selectCell = document.createElement('td');
    const selectCheckbox = document.createElement('input');
    selectCheckbox.type = 'checkbox';
    selectCheckbox.value = item.name;
    selectCheckbox.onclick = () => handleItemSelection(item, selectCheckbox);
    selectCell.appendChild(selectCheckbox);
    row.appendChild(selectCell);

    const nameCell = document.createElement('td');
    nameCell.textContent = item.name;  // Removed level_req from here
    row.appendChild(nameCell);

    const descCell = document.createElement('td');
    descCell.textContent = item.desc || 'No description';
    row.appendChild(descCell);

    const dataCell = document.createElement('td');
    let stats = item.data ? Object.entries(item.data) : [];
    if (item.tile_range) stats.push(['tile range', item.tile_range]);

    const excludedKeys = ["hue", "move", "spin", "alpha", "scale", "sprite", "brightness", "saturation", "damage stat"];
    const groupedStats = {};
    stats.forEach(([key, value]) => {
        if (excludedKeys.includes(key.toLowerCase()) || key.startsWith('!')) return;
        const match = key.match(/^(min|max)_(.+)$/);
        if (match) {
            const [, bound, statName] = match;
            if (!groupedStats[statName]) groupedStats[statName] = {};
            groupedStats[statName][bound] = value;
        } else {
            groupedStats[key] = value;
        }
    });

    // Start with Level Requirement as its own heading at the top (bolded)
    let formattedLines = [];
    if (item.data?.level_req !== undefined) {
        formattedLines.push(`Level Requirement: ${item.data.level_req}`);
    }

    // Then add grouped stats
    for (const key in groupedStats) {
        const value = groupedStats[key];
        if (typeof value === 'object' && value.min !== undefined && value.max !== undefined) {
            formattedLines.push(`${key.charAt(0).toUpperCase() + key.slice(1)}: ${value.min} - ${value.max}`);
        } else {
            formattedLines.push(`${key.charAt(0).toUpperCase() + key.slice(1)}: ${value}`);
        }
    }

    // Add level again at the bottom if you want — but to avoid duplication, let's skip that
    // if (item.data?.level_req !== undefined) {
    //     formattedLines.push(`Level: ${item.data.level_req}`);
    // }

    dataCell.textContent = formattedLines.join('\n');
    dataCell.className = 'data';
    row.appendChild(dataCell);

    // Repair Cost cell
    const repairCell = document.createElement('td');
    repairCell.textContent = item.repair_cost ?? '';
    row.appendChild(repairCell);

    // Uses cell
    const usesCell = document.createElement('td');
    usesCell.textContent = item.uses ?? '';
    row.appendChild(usesCell);

    // Sell Value cell
    const sellCell = document.createElement('td');
    sellCell.textContent = item.sell ?? '';
    row.appendChild(sellCell);

    // Handedness cell
    const handCell = document.createElement('td');
    handCell.textContent = item.handed ?? '';
    row.appendChild(handCell);

    // Favorite cell
    const favCell = document.createElement('td');
    const favCheckbox = document.createElement('input');
    favCheckbox.type = 'checkbox';
    favCheckbox.checked = isFavorite(item.name);
    favCheckbox.onclick = (e) => {
        e.stopPropagation();
        toggleFavorite(item);
    };
    favCell.appendChild(favCheckbox);
    row.appendChild(favCell);

    tableBody.appendChild(row);
});

        filterTable();
    } catch (error) {
        console.error('Error loading or displaying items:', error);
    }
}

function handleItemSelection(item, checkbox) {
    if (checkbox.checked) {
        if (!selectedItems.includes(item)) selectedItems.push(item);
    } else {
        selectedItems = selectedItems.filter(i => i !== item);
    }
}

function filterTable() {
    const search = document.getElementById('searchBar').value.toLowerCase();
    const weaponOnly = document.getElementById('weaponFilter').checked;
    const petOnly = document.getElementById('petFilter').checked;
    const recipeOnly = document.getElementById('recipeFilter').checked;
    const rareOnly = document.getElementById('rareFilter').checked;
    const favoritesOnly = document.getElementById('favoritesFilter').checked;
    const sortStat = document.getElementById("sortStat").value;

    const rows = document.querySelectorAll('#itemTable tbody tr');

    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        const name = cells[1].textContent.toLowerCase();
        const desc = cells[2].textContent.toLowerCase();
        const stats = cells[3].textContent.toLowerCase();
        const isWeapon = stats.includes('attack') || stats.includes('damage'); 
        const isPet = desc.includes('pet') || desc.includes('familiar');
        const isRecipe = desc.includes('recipe') || desc.includes('crafting');
        const isRare = desc.includes('rare') || desc.includes('legendary');

        const isFavoriteItem = cells[8].querySelector('input').checked;

        let show = true;

        if (search && !name.includes(search) && !desc.includes(search)) show = false;
        if (weaponOnly && !isWeapon) show = false;
        if (petOnly && !isPet) show = false;
        if (recipeOnly && !isRecipe) show = false;
        if (rareOnly && !isRare) show = false;
        if (favoritesOnly && !isFavoriteItem) show = false;

        row.style.display = show ? '' : 'none';
    });
}

function clearComparison() {
    selectedItems = [];
    const checkboxes = document.querySelectorAll('#itemTable tbody input[type="checkbox"]');
    checkboxes.forEach(cb => cb.checked = false);
}

function clearFavorites() {
    localStorage.removeItem('favorites');
    filterTable();
}

function generateShareLink() {
    if (selectedItems.length === 0) {
        alert('No items selected for comparison!');
        return;
    }
    const itemNames = selectedItems.map(item => item.name);
    const baseUrl = window.location.origin + window.location.pathname;
    const params = new URLSearchParams();
    params.set('compare', itemNames.join(','));
    const shareUrl = `${baseUrl}?${params.toString()}`;
    prompt('Share this link:', shareUrl);
}

function copyStats() {
    if (selectedItems.length === 0) {
        alert('No items selected!');
        return;
    }
    let text = selectedItems.map(item => {
        let stats = item.data ? Object.entries(item.data) : [];
        let textStats = stats.map(([k,v]) => `${k}: ${v}`).join('\n');
        return `${item.name}\n${textStats}\n`;
    }).join('\n');
    navigator.clipboard.writeText(text).then(() => {
        alert('Stats copied to clipboard!');
    });
}

function copyDescription() {
    if (selectedItems.length === 0) {
        alert('No items selected!');
        return;
    }
    let text = selectedItems.map(item => `${item.name}\n${item.desc}`).join('\n\n');
    navigator.clipboard.writeText(text).then(() => {
        alert('Description copied to clipboard!');
    });
}

function changeLanguage(lang) {
    // Placeholder for language change logic
    alert('Language change to: ' + lang + ' (Not implemented)');
}

// Initial load
fetchAndDisplayItems();
  </script>
</body>
</html>
